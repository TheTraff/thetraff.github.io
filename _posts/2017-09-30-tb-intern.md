---
layout: post
title:  "TicketBiscuit Internship Project"
date:   2017-09-30 00:10:45
categories: experience
---
During my time at TicketBiscuit as an intern, I had the opportunity to work on a project that would get significant use from the company's customers, albeit without them knowing about it. Because of this, the code had be very reliable, which is why we went with an all AWS architecture. 

The project consisted of creating a dynamic image resizing API that could be used for images on print-at-home tickets. The main idea was to put an AWS lambda function that took an image from storage, resized it to the desired size, and return that from an API call. While that is a very simplified version of the project, that gives you the general idea.

## Assembling the Technologies
#### AWS lambda
If you're not familiar with AWS lambda functions, they are (usually) simple functions that are run only when triggered by a certain event, such as an API call, an item added to storage, or other event triggers. They are typically used in order to create a "serverless" architecture. I put that in quotes because technically it's not serverlerss per se, but the person who set up the function doesn't have to actually worry about a server. This is the main draw of lambda functions, that they allow code that is only executed sparsely to not be a continuously running web service. If you're interested in reading more about lambda functions, make sure to check out the docs [here](lambda-docs).

#### API Gateway

In order to trigger the lambda function, we needed to be able to simply use a URL to access the resized image. For example, if the image with id '9999' was needed at size 300x300, then it would simply be _https://example.url/9999/300/300_. In order to do this, we used API gateway to create an API that would take the url parameters and trigger a lambda function with the url parameters, and return the newly resized image. Feel free to read more about API gateway [here](api-gateway-docs).

#### Cloudfront 

An important feature of  the old service was the caching ability. Since ticket layouts were the same for every customer, there would be a large amount of calls to the same url for each customer accessing that ticket. There was no reason to call the lambda function for every one of these calls, as it would be unneeded computation. Unfortunately, the caching ability of API gateway by itself was minimal at the time. In order to solve this, we added yet another layer to the project: an AWS Cloudfront distribution. With this, we were able to cahce each API call and not have to worry about unneeded calls to the lamda function. If ypou're interesed in more, check out the [docs](cloudfront-docs).

#### AWS S3

Last, but certainly not least, is the image storage. Keeping with the theme of AWS services, we decided to use an S3 bucket to store all of the client uploaded images. Before we migrated the images to S3, they were stored on a Rackspace cloud server, so we had to transfer about 25 GB of image files. I'll get more into that in a later section. If you want to read more about S3, check it out [here](S3-docs).



## Old Code + New Framework = FUN
  The old version of this project involved a .NET project written in C#, and we wanted to be able to reuse as much code as possible. Luckily AWS lambda supports using C# projects, but only in .NET core. .NET core is an open source, cross platform version of the .NET framework. This was one of the first challenges,
  as .NET core was relatively new at the time, and Lambda's support for it was even newer. 





[lambda-docs]: http://docs.aws.amazon.com/lambda/latest/dg/welcome.html
[api-gateway-docs]: http://docs.aws.amazon.com/apigateway/latest/developerguide/welcome.html
[cloudfront-docs]: http://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/Introduction.html
[S3-docs]: http://docs.aws.amazon.com/AmazonS3/latest/dev/Welcome.html